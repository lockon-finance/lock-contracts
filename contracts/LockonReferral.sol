//SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

import "./interfaces/ILockonVesting.sol";

/**
 * @title Lockon referral contract
 * @author LOCKON
 * @dev Allows users to claim referral rewards
 *
 */
contract LockonReferral is
    Initializable,
    OwnableUpgradeable,
    PausableUpgradeable,
    UUPSUpgradeable,
    EIP712Upgradeable,
    ReentrancyGuardUpgradeable
{
    using SafeERC20 for IERC20;
    /* ============ Constants ============== */

    /* ============ Struct ============ */

    // Reward claim request
    struct ClaimRequest {
        bytes32 requestId; // An ID for the reward claim request
        address beneficiary; // The address of the beneficiary
        address tokenAddress; // The address of the token
        uint256 rewardAmount; // The amount of reward tokens to be claimed
        bytes32 referralType; // The referralType represents the referral type
    }

    /* ============ State Variables ============ */

    /**
     * @dev Map lockon referral types to lockon vesting categoryId
     */
    mapping(bytes32 => uint256) public referralTypeToVestingCategoryId;

    /**
     * @dev Address of the validator
     */
    address public validatorAddress;

    /**
     * @dev Address of LOCKON vesting contract
     */
    address public lockonVestingAddress;

    /**
     * @dev Address of the stable token contract
     */
    address public stableTokenAddress;

    /**
     * @dev Address of the lock token contract
     */
    address public lockTokenAddress;

    /**
     * @dev Tracks the status of each requestId
     */
    mapping(bytes32 => bool) public isRequestIdProcessed;

    /**
     * @dev Reserved storage space to allow for layout changes in the future.
     */
    uint256[50] private __gap;

    /* ============ Events ============ */

    /**
     * @dev Emitted when an user claims their rewards
     *
     * @param sender Address of the function executor
     * @param requestId Id of the request generated by user
     * @param tokenAddress Token address of referral rewards claimed by the user
     * @param rewardAmount Amount of referral rewards claimed by the user
     * @param referralType The referralType represents the referral type
     */
    event ClaimedReferralReward(
        address indexed sender, bytes32 requestId, address tokenAddress, uint256 rewardAmount, bytes32 referralType
    );

    /**
     * Emitted when a user cancels a referral reward claim order
     *
     * @param sender Address of the function executor
     * @param requestId Identifier for the referral reward claim order being cancelled
     * @param tokenAddress Token address of referral rewards claimed by the user
     * @param rewardAmount Amount of referral rewards claimed by the user
     * @param referralType The referralType represents the referral type
     */
    event ClaimOrderCanceled(
        address indexed sender, bytes32 requestId, address tokenAddress, uint256 rewardAmount, bytes32 referralType
    );

    /**
     * Emitted when the validator address is updated
     *
     * @param sender Address of the function executor
     * @param validator New Validator address
     * @param timestamp Timestamp at which the address is updated
     */
    event ValidatorAddressUpdated(address indexed sender, address validator, uint256 timestamp);

    /**
     * Emitted when the admin allocates an amount of tokens to the contract
     *
     * @param sender Address of the function executor
     * @param tokenAddress Address of token that are allocated
     * @param rewardAmount Amount of tokens that are allocated
     */
    event RewardTokenAllocated(address indexed sender, address tokenAddress, uint256 rewardAmount);

    /**
     * Emitted when the admin withdraw an amount of  tokens from the contract
     *
     * @param sender Address of the function executor
     * @param tokenAddress Address of token that are deallocated
     * @param rewardAmount Amount of tokens that are deallocated
     */
    event RewardTokenDeallocated(address indexed sender, address tokenAddress, uint256 rewardAmount);

    /**
     * Emitted when the LOCKON Vesting address is updated
     *
     * @param sender Address of the function executor
     * @param lockonVesting New LOCKON Vesting address
     * @param timestamp Timestamp at which the address is updated
     */
    event LockonVestingUpdated(address indexed sender, address lockonVesting, uint256 timestamp);

    /**
     * @dev Emitted when a new lockon referral vesting category is added.
     *
     * @param referralType The referralType represents the referral type
     * @param vestingCategoryId The vestingCategoryId in lockon vesting.
     */
    event ReferralTypeToVestingCategoryIdUpdated(bytes32 referralType, uint256 vestingCategoryId);

    /**
     * @dev Emitted when a referral type to vesting category id is deleted.
     *
     * @param referralType The referralType represents the referral type
     * @param vestingCategoryId The vestingCategoryId in lockon vesting.
     */
    event ReferralTypeToVestingCategoryIdDeleted(bytes32 referralType, uint256 vestingCategoryId);

    /**
     * Emitted when the lock token address changes
     *
     * @param sender Address of the function executor
     * @param tokenAddress New token address
     * @param timestamp Timestamp at which the token address is added
     */
    event LockTokenUpdated(address indexed sender, address tokenAddress, uint256 timestamp);

    /**
     * Emitted when the stable token address changes
     *
     * @param sender Address of the function executor
     * @param tokenAddress New token address
     * @param timestamp Timestamp at which the token address is added
     */
    event StableTokenUpdated(address indexed sender, address tokenAddress, uint256 timestamp);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /**
     * Initializes the lockon referral contract
     *
     * @param _ownerAddress      Address of the owner of this contract
     * @param _validatorAddress Address of the validator of this contract
     * @param _lockonVestingAddress Address of the LOCKON Vesting contract
     * @param _stableTokenAddress  Address of the stable token
     * @param _lockTokenAddress  Address of the lock token
     * @param _referralTypes The new referral type list
     * @param _vestingCategoryIds The new list vesting category id for each referral type
     */
    function initialize(
        address _ownerAddress,
        address _validatorAddress,
        address _lockonVestingAddress,
        address _stableTokenAddress,
        address _lockTokenAddress,
        bytes32[] calldata _referralTypes,
        uint256[] calldata _vestingCategoryIds
    ) external initializer {
        require(_ownerAddress != address(0), "LOCKON Referral: owner is the zero address");
        require(_validatorAddress != address(0), "LOCKON Referral: validator is the zero address");
        require(_stableTokenAddress != address(0), "LOCKON Referral: stable token is the zero address");

        uint256 listIdLen = _referralTypes.length;
        require(
            _vestingCategoryIds.length == listIdLen,
            "LOCKON Referral: The list for referral type and vesting category id must have equal length"
        );

        // Initialize the contract and set the owner
        // This function should be called only once during deployment
        __Ownable_init_unchained(_ownerAddress);
        __UUPSUpgradeable_init();
        __Pausable_init();
        __ReentrancyGuard_init();
        EIP712Upgradeable.__EIP712_init("LOCKON_REFERRAL", "1");
        validatorAddress = _validatorAddress;
        stableTokenAddress = _stableTokenAddress;
        if (_lockonVestingAddress != address(0)) {
            lockonVestingAddress = _lockonVestingAddress;
        }
        if (_lockTokenAddress != address(0)) {
            lockTokenAddress = _lockTokenAddress;
        }

        for (uint256 i; i < listIdLen;) {
            require(_referralTypes[i] != "", "LOCKON Referral: _referralType is empty not allowed");
            require(_vestingCategoryIds[i] != 0, "LOCKON Referral: _vestingCategoryId is 0 not allowed");

            referralTypeToVestingCategoryId[_referralTypes[i]] = _vestingCategoryIds[i];
            unchecked {
                ++i;
            }
        }
    }

    /* ============ View Functions ============ */

    /**
     * @dev Validates if the given token address is either the stable token or the lock token.
     *
     * @param _tokenAddress The address of the token to validate
     */
    function isValidRewardToken(address _tokenAddress) internal view returns (bool) {
        return _tokenAddress == stableTokenAddress || _tokenAddress == lockTokenAddress;
    }

    /* ============ External Functions ============ */

    /**
     * @dev Allows an user to claim their lockon referral rewards
     * @param _requestId The Id of the request from users
     * @param _tokenAddress The address of token request from users
     * @param _rewardAmount The referral reward sent from user
     * @param _referralType The referralType represents the referral type
     * @param _signature The signature to validate the claim
     */
    function claimPendingReward(
        bytes32 _requestId,
        address _tokenAddress,
        uint256 _rewardAmount,
        bytes32 _referralType,
        bytes calldata _signature
    ) external whenNotPaused nonReentrant {
        require(!isRequestIdProcessed[_requestId], "LOCKON Referral: Request already processed");

        require(referralTypeToVestingCategoryId[_referralType] != 0, "LOCKON Referral: _referralType not supported");

        require(_tokenAddress != address(0), "LOCKON Referral: _tokenAddress is the zero address");

        require(isValidRewardToken(_tokenAddress), "LOCKON Referral: _tokenAddress not supported");

        require(_rewardAmount > 0, "LOCKON Referral: _rewardAmount must be greater than Zero");

        // Verify the signature to ensure the validity of the distribution
        require(
            getSignerForRequest(_requestId, msg.sender, _tokenAddress, _rewardAmount, _referralType, _signature)
                == validatorAddress,
            "LOCKON Referral: Invalid signature"
        );

        require(
            IERC20(_tokenAddress).balanceOf(address(this)) >= _rewardAmount,
            "LOCKON Referral: Insufficient funds contract"
        );

        // Mark the requestId as processed to prevent duplicate claim
        isRequestIdProcessed[_requestId] = true;
        if (_tokenAddress != lockTokenAddress) {
            SafeERC20.safeTransfer(IERC20(_tokenAddress), msg.sender, _rewardAmount);
        } else {
            require(lockonVestingAddress != address(0), "LOCKON Referral: lockonVestingAddress is the zero address");

            // Approve the LOCKON vesting contract to spend the reward token
            uint256 currentAllowance = IERC20(_tokenAddress).allowance(address(this), lockonVestingAddress);
            if (currentAllowance < _rewardAmount) {
                IERC20(_tokenAddress).safeIncreaseAllowance(lockonVestingAddress, _rewardAmount - currentAllowance);
            }

            uint256 vestingCategoryId = referralTypeToVestingCategoryId[_referralType];
            ILockonVesting(lockonVestingAddress).deposit(msg.sender, _rewardAmount, vestingCategoryId);
        }

        emit ClaimedReferralReward(msg.sender, _requestId, _tokenAddress, _rewardAmount, _referralType);
    }

    /**
     * @dev Allows a user to cancel a referral reward claim order for a specific pool
     *
     * @param _requestId An ID for the referral reward claim order
     * @param _tokenAddress The address of token request from users
     * @param _rewardAmount The referral reward sent from user
     * @param _referralType The referralType represents the referral type
     * @param _signature The signature to validate the cancellation
     */
    function cancelClaimOrder(
        bytes32 _requestId,
        address _tokenAddress,
        uint256 _rewardAmount,
        bytes32 _referralType,
        bytes calldata _signature
    ) external whenNotPaused {
        require(!isRequestIdProcessed[_requestId], "LOCKON Referral: Request already processed");

        // Verify the signature to ensure the validity of the cancellation
        require(
            getSignerForRequest(_requestId, msg.sender, _tokenAddress, _rewardAmount, _referralType, _signature)
                == validatorAddress,
            "LOCKON Referral: Invalid signature"
        );
        // Mark the order as cancelled
        isRequestIdProcessed[_requestId] = true;

        emit ClaimOrderCanceled(msg.sender, _requestId, _tokenAddress, _rewardAmount, _referralType);
    }

    /* ============ PRIVILEGED OWNER / GOVERNANCE Functions ============ */

    /**
     * @notice Pauses the contract, preventing certain functions from being executed.
     * Only the owner can invoke this function.
     */
    function pause() external onlyOwner {
        _pause(); // Calls the internal _pause function from the Pausable library to pause the contract.
    }

    /**
     * @notice Unpauses the contract, allowing normal operation after being paused.
     * Only the owner can invoke this function.
     */
    function unpause() external onlyOwner {
        _unpause(); // Calls the internal _unpause function from the Pausable library to unpause the contract.
    }

    /**
     * @dev Adds a new referral type to the `referralTypeToVestingCategoryId` mapping.
     *
     * @param _referralType The type of the referral type to add.
     * @param _vestingCategoryId The vesting categoryId of referral type
     */
    function setReferralTypeToVestingCategoryId(bytes32 _referralType, uint256 _vestingCategoryId) external onlyOwner {
        require(_referralType != "", "LOCKON Referral: _referralType is empty not allowed");

        referralTypeToVestingCategoryId[_referralType] = _vestingCategoryId;
        if (_vestingCategoryId == 0) {
            emit ReferralTypeToVestingCategoryIdDeleted(_referralType, _vestingCategoryId);
        } else {
            emit ReferralTypeToVestingCategoryIdUpdated(_referralType, _vestingCategoryId);
        }
    }

    /**
     * @dev Set the address of LOCKON Vesting contract responsible for vested distributed reward
     * @param _lockonVestingAddress  Address of the LOCKON vesting contract
     */
    function setLockonVesting(address _lockonVestingAddress) external onlyOwner {
        require(_lockonVestingAddress != address(0), "LOCKON Referral: Zero address not allowed");
        lockonVestingAddress = _lockonVestingAddress;
        emit LockonVestingUpdated(msg.sender, lockonVestingAddress, block.timestamp);
    }

    /**
     * @dev Set the validator address responsible for reward distribution
     * @param _validatorAddress  Address of the validator
     */
    function setValidatorAddress(address _validatorAddress) external onlyOwner {
        require(_validatorAddress != address(0), "LOCKON Referral: Zero address not allowed");
        validatorAddress = _validatorAddress;
        emit ValidatorAddressUpdated(msg.sender, validatorAddress, block.timestamp);
    }

    /**
     * @dev Set the lock token address allowed to be used in the contract
     * @param _lockTokenAddress lock token address
     */
    function setLockTokenAddress(address _lockTokenAddress) external onlyOwner {
        require(_lockTokenAddress != address(0), "LOCKON Referral: Zero address not allowed");
        lockTokenAddress = _lockTokenAddress;
        emit LockTokenUpdated(msg.sender, lockTokenAddress, block.timestamp);
    }

    /**
     * @dev Set the stable token address allowed to be used in the contract
     * @param _stableTokenAddress stable token address
     */
    function setStableTokenAddress(address _stableTokenAddress) external onlyOwner {
        require(_stableTokenAddress != address(0), "LOCKON Referral: Zero address not allowed");
        stableTokenAddress = _stableTokenAddress;
        emit StableTokenUpdated(msg.sender, stableTokenAddress, block.timestamp);
    }

    /**
     * @dev Allows the owner to add ERC20 tokens to contract referral
     *
     * @param _tokenAddress The token address to be added
     * @param _amount The token amount to be added
     */
    function allocateRewardToken(address _tokenAddress, uint256 _amount) external onlyOwner nonReentrant {
        require(_tokenAddress != address(0), "LOCKON Referral: Zero address not allowed");

        require(isValidRewardToken(_tokenAddress), "LOCKON Referral: _tokenAddress not supported");

        require(_amount > 0, "LOCKON Referral: _amount must be greater than Zero");

        SafeERC20.safeTransferFrom(IERC20(_tokenAddress), msg.sender, address(this), _amount);
        emit RewardTokenAllocated(msg.sender, _tokenAddress, _amount);
    }

    /**
     * @dev Allows the owner to withdraw ERC20 tokens from contract referral
     *
     * @param _tokenAddress The token address to be withdrawn
     * @param _amount The token amount to be withdrawn
     */
    function deallocateRewardToken(address _tokenAddress, uint256 _amount) external onlyOwner nonReentrant {
        require(_tokenAddress != address(0), "LOCKON Referral: Zero address not allowed");

        require(isValidRewardToken(_tokenAddress), "LOCKON Referral: _tokenAddress not supported");

        require(_amount > 0, "LOCKON Referral: _amount must be greater than Zero");

        SafeERC20.safeTransfer(IERC20(_tokenAddress), msg.sender, _amount);
        emit RewardTokenDeallocated(msg.sender, _tokenAddress, _amount);
    }

    /* ============ Verify signature Functions ============ */

    /**
     * @dev Get signer from data and signature of the reward claim request
     *
     * @param _requestId An ID for the reward claim request
     * @param _beneficiary The address of the beneficiary
     * @param _tokenAddress The address of token request from users
     * @param _rewardAmount The amount of reward tokens to be claimed
     * @param _referralType The referralType represents the referral type
     * @param _signature The signature to validate the reward claim request
     */
    function getSignerForRequest(
        bytes32 _requestId,
        address _beneficiary,
        address _tokenAddress,
        uint256 _rewardAmount,
        bytes32 _referralType,
        bytes calldata _signature
    ) public view returns (address) {
        ClaimRequest memory claimRequest =
            ClaimRequest(_requestId, _beneficiary, _tokenAddress, _rewardAmount, _referralType);
        address signer = _verifyClaimRequest(claimRequest, _signature);
        return signer;
    }

    /**
     * @dev Return domain separator for  referral
     */
    function getDomainSeparator() external view returns (bytes32) {
        return _domainSeparatorV4();
    }

    /**
     * @dev Verify the reward claim request with signature
     *
     * @param _claimRequest An ID for the reward claim request
     * @param _signature The signature to validate the claim request
     */
    function _verifyClaimRequest(ClaimRequest memory _claimRequest, bytes memory _signature)
        private
        view
        returns (address)
    {
        bytes32 digest = _hashTypedDataV4(
            keccak256(
                abi.encode(
                    keccak256(
                        "ClaimRequest(bytes32 requestId,address beneficiary,address tokenAddress,uint256 rewardAmount,bytes32 referralType)"
                    ),
                    _claimRequest.requestId,
                    _claimRequest.beneficiary,
                    _claimRequest.tokenAddress,
                    _claimRequest.rewardAmount,
                    _claimRequest.referralType
                )
            )
        );
        return ECDSA.recover(digest, _signature);
    }

    /**
     * @dev Override function from UUPS contract for upgrade authorize
     * @param newImplementation  Address of the new implementation address
     */
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
}
